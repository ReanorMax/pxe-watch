import re
import string
from . import read_file, write_file

START_MARKER = '# AUTOGENERATED-DISKS-START'
END_MARKER = '# AUTOGENERATED-DISKS-END'


def _generate_disk_block(disk_count: int, disk_size_gb: int) -> str:
    """Generate preseed disk/raid configuration block."""
    letters = string.ascii_lowercase
    devices = [f"/dev/sd{letters[i]}" for i in range(disk_count)]
    total_mb = disk_size_gb * 1024
    boot_mb = 512
    root_mb = max(total_mb - boot_mb, 1)
    part1 = [f"{d}1" for d in devices]
    part2 = [f"{d}2" for d in devices]
    raid_boot = '#'.join(part1)
    raid_root = '#'.join(part2)
    block = f"""# Disk configuration: {disk_count} x {disk_size_gb}GB
# /boot: {boot_mb}MB, /: {root_mb}MB
d-i partman-auto/disk string {' '.join(devices)}
d-i partman-auto/method string raid
d-i partman-auto/choose_recipe select boot-root
d-i partman-auto/expert_recipe string                         \\
      boot-root ::                                            \\
              {boot_mb} {boot_mb} {boot_mb} ext4              \\
                      $primary{{ }} $bootable{{ }}            \\
                      method{{ raid }}                        \\
              .                                               \\
              {root_mb} {root_mb} {root_mb} ext4              \\
                      method{{ raid }}                        \\
              .
d-i partman-auto-raid/recipe string                           \\
      1 {disk_count} 0 ext4 /                                 \\
              {raid_root}                                     \\
      .                                                       \\
      1 {disk_count} 0 ext4 /boot                             \\
              {raid_boot}                                     \\
      ."""
    return block


def update_preseed_disks(path: str, disk_count: int, disk_size_gb: int) -> str:
    """Update disk configuration in preseed file in-place."""
    content = read_file(path)
    block = _generate_disk_block(disk_count, disk_size_gb)
    if START_MARKER in content and END_MARKER in content:
        pattern = re.compile(
            f"{re.escape(START_MARKER)}.*?{re.escape(END_MARKER)}",
            re.DOTALL,
        )
        new_content = pattern.sub(
            f"{START_MARKER}\n{block}\n{END_MARKER}", content
        )
    else:
        if not content.endswith('\n'):
            content += '\n'
        new_content = f"{content}{START_MARKER}\n{block}\n{END_MARKER}\n"
    write_file(path, new_content)
    return new_content
